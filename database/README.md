# 데이터베이스

- [데이터베이스](#데이터베이스)
- [Index](#Index)

## 데이터베이스

> 데이터베이스 이전의 데이터 관리는 파일 시스템을 이용하여서 이루어졌다.  
> 데이터 관리의 중요성이 증가하며 데이터의 종속성, 중복성, 무결성에 대한 문제를 해결하기 위한 방법으로 데이터베이스가 나오게되었다.

1. 데이터베이스 : 데이터베이스는 데이터의 독립성, 데이터의 무결성, 데이터의 보안성, 데이터의 일관성, 데이터의 중복 최소화라는 특징을 가진 데이터 의 집합이다.
2. 독립성 : 물리적 독립성(확장을 위한 프로그램 수정 불필요), 논리적 독립성(논리적 구조로 다양한 프로그램의 논리적 요구를 만족 가능)을 말한다.
3. 무결성 : 여러 경로을 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
4. 보안성 : 인가된 사용자만 데이터베이스와 내부 자원에 접근 가능한 권한을 설정이 가능함을 말한다.
5. 일관성 : 연관된 정보를 논리적 구조로 관리 가능해 데이터 변경시 데이터 불일치성을 배제 가능함을 말한다.
6. 중복 최소화 : 데이터 통합을 통해서 같은 자료를 중복 되는 것을 최소화 시킬 수 있다.
7. 성능 : 디스크 I/O을 최소화 하는 것에 관련 되어 있다. 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터에 접근 가능한가에 달려있고 랜덤 보다는 순차적인 I/O가 당연히 성능에 더 좋다. 그런 점을 생각 하는 것이 쿼리 튜닝이고, 또 한 최소 시간으로 원하는 데이터를 가져올 것인가는 여러가지 방법이 있다.(디스크 접근을 최소화 한다거나 그런 방식도 있고, 커버링 인덱스나 정규화 방식의 변경등)

## Index

> 데이터베이스에서의 인덱스는 색인이라고 표현 할 수 있다. 데이터 검색에서 원하는 데이터를 얻기 위해서 모든 데이터를 검색한다면 원하는 결과를 얻기 까지 많은 시간이 걸린다.  
> 인덱스는 그 소요 되는 시간을 줄이기 위해서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스라는 자료구조로 만들어서 검색을한다.
> 결국 데이터베이스에서의 인덱스는 저장이나 삭제, 수정 등의 성능을 전략적으로 희생해서 데이터 검색에 걸리는 시간을 줄이기 위한 자료구조이다.

1. Index 자료구조 : B+-Tree 인덱스 알고리즘, Hash 인덱스 알고리즘을 주로 사용한다. 그 이유는 SELECT 질의 조건에 부등호 연산이 포함 되기 때문으로 hashtable은 동등 연산에만 특화 되어 있기에 데이터베이스의 자료구조로는 적합하지 않다.
2. B+-Tree 알고리즘을 일반적으로 사용하며, B+-Tree 알고리즘은 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱한다. Hash 알고리즘의 경우는 컬럼의 값을 해시로 계산해서 인덱싱하기에 매우 빠른 검색이 가능하지만, 값을 변형하기에 부분 탐색에서 인덱스를 사용 할 수 없다. 주로 메모리 기반 데이터베이스에서 많이 사용하는 방식이다.
3. 클러스터드 인덱스 : 물리적으로 인접한 장소에 저장 된 데이터를 묶어서 저장하는 인덱스, 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 프라이머리 키 값이 변경되면 해당 레코드의 물리적 저장 위치 역시 변한다. 그렇기 때문에 PK는 신중히 정해야한다. 클러스터드 인덱스는 PK테이블당 한 개만 생성 할 수 있다.
4. Composite Index : 인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title을 검색할 시에는 Index 효과를 볼 수 있지만 author 만으로 검색하는 경우는 Index를 타지 않는다. 즉, SELECT 질의를 어떻게 할 것인가는 Index를 어떻게 생성할 것인가에 많은 영향을 준다.
5. 인덱스는 SELECT 질의의 성능을 월등히 향상시키는 INDEX는 INSERT, DELECT, UPDATE 질의에서는 별도의 과정(인덱스를 생성하고 관리 하는 과정)이 추가 되기에 성능에 악영향을 준다. 실제 데이터와 INDEX 구조의 데이터 수는 서로 다를 수 있으며 이로 인해 성능에 악영향을 준다.
6. 인덱스는 해당 칼럼이 유니크 한 타입일 수록 더 효율적이 된다.
7. 마지막으로 해당 내용은 DBMS마다 각각 세부적인 차이가 있다.