# 데이터베이스

- [데이터베이스](#데이터베이스)
- [Index](#Index)
- [정규화에 대하여](#정규화에-대하여)
- [트랜잭션](#트랜잭션)
- [Statement vs PreparedStatement](#Statement-vs-PreparedStatement)

## 데이터베이스

> 데이터베이스 이전의 데이터 관리는 파일 시스템을 이용하여서 이루어졌다.  
> 데이터 관리의 중요성이 증가하며 데이터의 종속성, 중복성, 무결성에 대한 문제를 해결하기 위한 방법으로 데이터베이스가 나오게되었다.

1. 데이터베이스 : 데이터베이스는 데이터의 독립성, 데이터의 무결성, 데이터의 보안성, 데이터의 일관성, 데이터의 중복 최소화라는 특징을 가진 데이터 의 집합이다.
2. 독립성 : 물리적 독립성(확장을 위한 프로그램 수정 불필요), 논리적 독립성(논리적 구조로 다양한 프로그램의 논리적 요구를 만족 가능)을 말한다.
3. 무결성 : 여러 경로을 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
4. 보안성 : 인가된 사용자만 데이터베이스와 내부 자원에 접근 가능한 권한을 설정이 가능함을 말한다.
5. 일관성 : 연관된 정보를 논리적 구조로 관리 가능해 데이터 변경시 데이터 불일치성을 배제 가능함을 말한다.
6. 중복 최소화 : 데이터 통합을 통해서 같은 자료를 중복 되는 것을 최소화 시킬 수 있다.
7. 성능 : 디스크 I/O을 최소화 하는 것에 관련 되어 있다. 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터에 접근 가능한가에 달려있고 랜덤 보다는 순차적인 I/O가 당연히 성능에 더 좋다. 그런 점을 생각 하는 것이 쿼리 튜닝이고, 또 한 최소 시간으로 원하는 데이터를 가져올 것인가는 여러가지 방법이 있다.(디스크 접근을 최소화 한다거나 그런 방식도 있고, 커버링 인덱스나 정규화 방식의 변경등)

## Index

> 데이터베이스에서의 인덱스는 색인이라고 표현 할 수 있다. 데이터 검색에서 원하는 데이터를 얻기 위해서 모든 데이터를 검색한다면 원하는 결과를 얻기 까지 많은 시간이 걸린다.  
> 인덱스는 그 소요 되는 시간을 줄이기 위해서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스라는 자료구조로 만들어서 검색을한다.
> 결국 데이터베이스에서의 인덱스는 저장이나 삭제, 수정 등의 성능을 전략적으로 희생해서 데이터 검색에 걸리는 시간을 줄이기 위한 자료구조이다.

1. Index 자료구조 : B+-Tree 인덱스 알고리즘, Hash 인덱스 알고리즘을 주로 사용한다. 그 이유는 SELECT 질의 조건에 부등호 연산이 포함 되기 때문으로 hashtable은 동등 연산에만 특화 되어 있기에 데이터베이스의 자료구조로는 적합하지 않다.
2. B+-Tree 알고리즘을 일반적으로 사용하며, B+-Tree 알고리즘은 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱한다. Hash 알고리즘의 경우는 컬럼의 값을 해시로 계산해서 인덱싱하기에 매우 빠른 검색이 가능하지만, 값을 변형하기에 부분 탐색에서 인덱스를 사용 할 수 없다. 주로 메모리 기반 데이터베이스에서 많이 사용하는 방식이다.
3. 클러스터드 인덱스 : 물리적으로 인접한 장소에 저장 된 데이터를 묶어서 저장하는 인덱스, 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 프라이머리 키 값이 변경되면 해당 레코드의 물리적 저장 위치 역시 변한다. 그렇기 때문에 PK는 신중히 정해야한다. 클러스터드 인덱스는 PK테이블당 한 개만 생성 할 수 있다.
4. Composite Index : 인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title을 검색할 시에는 Index 효과를 볼 수 있지만 author 만으로 검색하는 경우는 Index를 타지 않는다. 즉, SELECT 질의를 어떻게 할 것인가는 Index를 어떻게 생성할 것인가에 많은 영향을 준다.
5. 인덱스는 SELECT 질의의 성능을 월등히 향상시키는 INDEX는 INSERT, DELECT, UPDATE 질의에서는 별도의 과정(인덱스를 생성하고 관리 하는 과정)이 추가 되기에 성능에 악영향을 준다. 실제 데이터와 INDEX 구조의 데이터 수는 서로 다를 수 있으며 이로 인해 성능에 악영향을 준다.
6. 인덱스는 해당 칼럼이 유니크 한 타입일 수록 더 효율적이 된다.
7. 마지막으로 해당 내용은 DBMS마다 각각 세부적인 차이가 있다.

## 정규화에 대하여

> 한 테이블(릴레이션)에 여러 엔티티의 속성이 혼합되면 정보가 중복 저장 되어서 저장 공간을 낭비하고, 중복 정보로 인해서 갱신 이상이 발생한다.  
> 이런 문제를 해결하기 위해서 관계형 데이터베이스에는 정규화라는 기법이 존재한다.  
> 정규화란 관계형 데이터베이스에서 데이터의 중복을 최소로 하는 구조를 만드는 작업이다. 나쁜 릴레이션을 더 좋고 작은 릴레이션으로 나누는 작업을 말한다.

1. 갱신 이상 : 갱신 이상에는 크게 3가지가 존재한다. 각각 삽입 이상(insertion anomalies), 삭제 이상(deletion anomalies), 수정(갱신) 이상(modification anomalies)이다. 원하지 않는 자료 삽입 되거나 자료가 부족해 삽입 되지 않는 것이 삽입 이상, 원하는 자료 이상의 튜플 전체가 삭제 되는 게 삭제 이상, 갱신이 정확하지 않거나 일부 튜플만 갱신 되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 것이 수정 이상이다.
2. 나쁜 릴레이션 : 엔티티를 구성하는 애트리뷰트 간에 함수적 종속성(Functional Dependency)를 통해 판단, 각각 정규형에 따라 알맞는 함수적 종속성을 만족시키는 것이 좋은 릴레이션이고 만족시키지 못하면 나쁜 릴레이션이다.
3. 함수적 종속성 : 애트리뷰트 데이터들의 의미 와 애트리뷰트 간의 상호 관계로 유도되는 제약조건, X가 Y를 유일하게 결정 => X는 Y를 함수적으로 결정, 애트리뷰트들의 관계로 부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다.
4. 정규형의 충족 조건 : 분해 대상의 분해 집합은 무손실 조인을 보장해야하고, 분해 집합은 함수적 종속성을 보존해야한다.
5. 제 1 정규형 : 애트리뷰트 도메인이 오직 아토믹(원자 값)만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야한다. 즉, 복합, 다중값 애트리뷰트, 중첩 릴레이션 등 비 원자적인 애트리뷰트를 허용하지 않는 정규형이다.
6. 제 2 정규형 : 모든 비주요 애트리뷰트 들이 주요 애트리뷰트에 대해서 완전 함수적 종속인 정규형, 완전 함수적 종속이란 x => y 일떄 x의 애트리뷰트를 하나라도 제거하면 더 이상 함수적 종속성이 성립 되지 않는 경우 키가 아닌 열들이 각각 후보키에 대해 결정하는 형태이다.
7. 제 3 정규형 : 어떤 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않은 정규형, 이행 함수적 종속이란 x => y, y => z의 경우 추론 되는 x => z 종속 관계를 말한다. 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속 되지 않는 형태.
8. BCNF(Boyce-Codd) 정규형 : 여러 후보키가 존재 하는 릴레이션에 해당하는 정규형, 복잡한 식별자 관계로 발생 하는 문제를 해결 하기 위해 제 3 정규형을 보완한다. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해 과정을 말한다.
9. 각 정규형은 선행 정규형보다 엄격한 조건을 가진다. 모든 제 2 정규형 릴레이션은 제 1 정규형을 가진다. 모든 제 3 정규형은 제 2 정규형을 갖는다. 모든 BCNF 정규형은 제 3 정규형을 가진다.
10. 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.

### 정규화의 장단점

1. 데이터베이스 변경시 이상현상을 제거 해당 현상으로 발생하는 문제점을 해결 가능하다.
2. 데이터베이스 구조 확장 시 재 디자인 최소화 가능하다. 정규화 된 구조에서는 구조 확장시 구조를 변경하지 않거나 일부만 변경해도 된다. => 연동된 프로그램에 최소한의 영향, 프로그램 수명 연장, 물론 ORM, 디자인 패턴등 방법은 많다.
3. 사용자에게 데이터 모델을 더욱 의미 있게 제공가능 정규화는 현실 세계의 개념들과 그들 사이를 반영한다.
4. 릴레이션 간의 JOIN연산이 많아진다. 이로 인해 질의 응답 시간이 느려진다. 정규화로 인해서 얻는 이점(데이터 용량 최적화) 과 상충하기에 적절한 정규화가 필요하다.
5. 반정규화(De-Normalization, 비정규화) : 정규화 된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나로 조회 성능 향상을 위해 고려한다.
6. 반정규화 대상 : 자주 사용 되며, 엑세스 하는 프로세스가 많고, 항상 일정한 범위를 조회할시, 대량의 데이터에 대량의 범위를 자주 처리 하고 성능상 이슈가 있을시, 지나치게 조인을 많이 사용하게 되어 기술적으로 조회가 어려울 시가 있다.
7. 반정규화 주의점 : 과도하게 적용하면 데이터 무결성, 조회 외의 질의가 느려질 수 있다.

## 트랜잭션

> 트랜잭션(Transaction)은 작업의 완전성을 보장하는 것으로 작업중 일부만 성공 하는 경우 원복하여 작업중 일부만 적용되는 현상이 발생하지 않게 하는 기능  
> 작업의 논리적 단위 또는 데이터에 접근 또는 변경하는 프로그램 단위.  
> 잠금LOCK과의 차이는 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 작업의 완정성을 제어하기 위한 기능이라는게 차이이다.

1. 트랜잭션은 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)의 특성을 가진다.
2. 원자성 : 만약 트랙잭션 중간에 어떠한 문제가 발생한다면 해당 트랜잭션의 어떤 작업도 수행 되어서는 안되며, 아무런 문제가 발생하지 않을 경우만 모든 작업이 수행된다.
3. 일관성 : 트랙잭션이 완료 전 후 상태가 동일하게 데이터의 일관성을 보장해야한다.
4. 고립성 : 각 트랜잭션은 서로 독립적이여야한다.
5. 지속성 : 트랜잭션이 정상적으로 완료 된 다음에는 영구적으로 데이터베이스에 작업 결과가 저장되어야한다.

### 트랜잭션의 상태

1. 트랙잭션의 상태에는 크게 5가지가 있는데 각각 Active, Failed, Partially Committed, Committed, Aborted라 지칭한다.
2. Active : 트랜잭션의 활동 상태, 트랜잭션이 실행중이며 동작중인 상태.
3. Failed : 트랜잭션 실패 상태, 트랜잭션이 더 이상 정상적으로 진행 불가능한 상태.
4. Patially Committed : 트랜잭션의 커밋 명령이 도착한 상태, 커밋전의 sql문이 수행되고 커밋만 남은 상태.
5. Committed : 트랜잭션 완료 상태, 트랜잭션이 정상적으로 완료된 상태
6. Aborted : 트랜잭션이 취소 상태, 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태.
7. Partially Committed 와 Committed의 차이 : 커밋 요청에 의해Partially Committed에서 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다.
8. 트랜잭션의 상태는 트랜잭션이 시작하면 관련 작업을 수행하고 그 수행이 성공적이면 커밋요청을 오류가 있다면 실패로 커밋이 성공적이면 커밋완료가 커밋이 불가능하면 다시 실패로 상태가 변하여 결국 취소되거나 커밋이 된다.

### 트랜잭션의 교착상태

1. 트랜잭션의 범위는 최소화 되는게 좋다. 각 트랜잭션 단위가 커지거나 길어져 제한적인 자원에 대한 소유권을 모두 차지하게 된다면 다른 트랜잭션은 그 트랜잭션의 작업이 끝날때 까지 기다려야하는 상황이 발생한다.
2. 교착상태 : 복수의 트랜잭션이 특정 자원의 잠금을 획득한채 다른 트랜잭션이 소유하고 있는 잠금을 요구하여 아무리 기다려도 상황이 변하지 않는 상태를 교착상태라 한다.
3. MySQL MVCC에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 잠금을 획득한다. (기본은 행에 대한 잠금) 그렇기에 같은 트랜잭션에서 서로간의 갱신연산을 하면 DeadLock(교착상태)기 발생한다.
4. MVCC(다중 버전 동시성 제어) : 갱신 연산이 일어나는 동안 다른 사람이 해당 자원에 접근을 할시 그 사람은 일관적이지 않고 반쯤 갱신된 데이터 조각을 볼 수 있는데. 그것을 막는 방법으로 트랜잭션 메모리 구현에 사용되는 동시성 제어 방법이다.  
5. 교착 상태의 빈도를 낮추는 방법 : 자주 커밋하고, 정해진 순서로 테이블에 접근하고, 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 기피하고, 잠금 단위를 포괄적으로 획득하여서 갱신을 직렬화 하면 교착상태를 회피하기 좋다.

## Statement vs PreparedStatement

> Statement는 쿼리 자체에 조건이 들어가는 Dynamic SQL 방식을 의미, PreparedStatement는 변수를 설정하고 바인딩하는 Static SQL이 사용  
> PreparedStatement는 데이터베이스 관리 시스템(DBMS)에서 동일하거나 비슷한 데이터베이스 문을 높은 효율성으로 반복적으로 실행하기 위해 사용되는 기능이다.  
> 일반적으로 쿼리나 업데이트와 같은 SQL 문과 함께 사용되는 프리페어드 스테이트먼트는 템플릿의 형태를 취하며, 그 템플릿 안으로 특정한 상수값이 매 실행 때마다 대체된다.

1. PreparedStatement가 파싱 타임을 줄여주는 것은 분명하지만 Static sql을 사용하는데 따르는 퍼포먼스 저하를 고려하지 않을 수 없다.
2. DB 질의에서 가장 큰 비중을 차지하는 것은 테이블에서 레코드(row)를 가져오는 과정이며, SQL문 파싱 자체는 평균적으로 레코드 셀렉의 10분의 1정도의 시간을 소요한다.
3. PreparedStatement는 Dynamic SQL과는 다르게 Static SQL 방식을 사용하여 SQL Injection 등의 문제를 보완해주기에 반드시 필요한 경우가 아니라면 Static SQL방식을 채택하는게 올바르다.
4. Static SQL : String 형 변수에 쿼리 문장을 담지 않고 코드 사이에 직접 기술 다른 말로 'Embedded SQL' 이라고도 한다. 런타임 시에 절대 변하지 않아 PreCompile 단계에서 구문 분석, 유효 오브젝트 여부, 오브젝트 액세스 권한 등을 체크하는 것이 가능하다는 장점을 가진다.
5. Dynamic SQL : String 변수에 답아서 처리하는 SQL문 즉 변수를 사용 하므로서 쿼리문을 동적으로 바꿀수 있으며 런타임시에 사용자가 SQL에 대해서 입력(전체 입력 및 변경)이 가능하다. Semeantic 체크는 DB 접속을 통해 이루어지지만 Syntanx 체크는 PreCompiler로 파싱씨 에러가 발생 할 수 있으므로 Dynamic SQL을 사용해 해결한다.
6. 결국 Statment는 변수를 문자와 결합 하므로서 얼마나 하드 파싱이 일어나 성능이 저하가 되는지, 라이브러리 캐시에 얼마나 심한 경합이 발생에 따라 바인드 변수의 사용 여부에 초점을 맞춰 작성을 해야 한다.